<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <title>U.S. States</title>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="http://libs.cartocdn.com/cartodb.js/v2/cartodb.js"></script>
    <style type="text/css">

    body{
        background:white;
        margin: 0; padding: 0;
        height: 100%; width: 100%;
    }
    svg {
      height: 100%; width: 100%;
      background: white;
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      top: 0;
    }
    svg:active {
      cursor: move;
      cursor: -moz-grabbing;
      cursor: -webkit-grabbing;
    }
    .globe {
      fill: transparant;
    }
    #first_layer path {
      fill-opacity:0.8;
      fill: white;
      stroke: #667683;
      stroke-width:2px;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    #second_layer path {
      cursor: pointer;
      fill-opacity:.2;
      fill: #667683;

      stroke: #667683;
      stroke-width:1px;
      stroke-linecap: round;
      stroke-linejoin: round;
      stroke-dasharray: 2,2;

      z-index: 100;
    }
    #third_layer circle {
      cursor: pointer;
      fill-opacity:.5;
      fill: blue;
      stroke-width:0.1px;
      stroke:black;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    .halo {
      font-weight: 700;
      fill: none;
      stroke: white;
      stroke-width:4px;
      font-size: 14px; 
    }
    .text {
      font-weight: 700;
      fill: #777;
      stroke: none;
      stroke-width:0px;
      font-size: 14px; 
    }

    </style>
  </head>
  <body>
    <div id='map' class='dark'>
        <div id="earthquakes"></div>
    </div>

    <script type="text/javascript">

    var first_layer = 'subunits_netherlands';
    var second_layer = 'gasfields_netherlands';
    var third_layer = 'boreholes_netherlands';

    var sql = new cartodb.SQL({ user: 'bouke', format: 'geojson', dp: 5});

    // Define our SVG element outside our SQL functions
    var svg = d3.select("body")
            .append("svg")
            // .call(d3.behavior.zoom()
            //     .on("zoom", redraw))
            .append("g");

    // Our projection.
    var xy = d3.geo.mercator();
        xy.scale(200000);
        xy.center([5.8,52]);

    svg.append("g").attr("id", "first_layer");
    svg.append("g").attr("id", "second_layer");
    svg.append("g").attr("id", "third_layer");

    var path = d3.geo.path();

    sql.execute("SELECT the_geom FROM {{table_name}} WHERE the_geom IS NOT NULL", {table_name: first_layer})
      .done(function(collection) {
          svg.select("#first_layer")
            .selectAll("path")
              .data(collection.features)
            .enter().append("path")
            .attr("d", path.projection(xy))
            .on("mousedown", function(t){
                d3.selectAll("text").remove(); 
             });
      })
      .error(function(errors) {
        // console.log('Errors! Oh no!')
      });


    sql.execute("SELECT the_geom FROM {{table_name}} WHERE the_geom IS NOT NULL", {table_name: second_layer})
      .done(function(collection) {
          svg.select("#second_layer")
            .selectAll("path")
              .data(collection.features)
            .enter().append("path")
            .attr("d", path.projection(xy))
            .on("mousedown", function(t){
                d3.selectAll("text").remove(); 
             });
      })
      .error(function(errors) {
        // console.log('Errors! Oh no!')
      });

    sql.execute("SELECT the_geom FROM {{table_name}} WHERE the_geom IS NOT NULL", {table_name: third_layer})
      .done(function(collection) {
        console.log('collection', collection)

        for(var i in collection.features) {
        	var c = collection.features[i];

	        svg.select("#third_layer")
	      	  .append("circle")
	          .attr("cx", xy(c.geometry.coordinates)[0])
	          .attr("cy", xy(c.geometry.coordinates)[1])
	          .attr("r", 1);
        }
      });


    // Request our data and add it to the earthquakesLayer.
d3.json('earthquakes.geojson', function(err, data) {
    // earthquakesLayer.addData(data);
    earthquakes_callback(data);
    // setBrush(data);
});
 

     //  var earthquakes;
	    // sql.execute("SELECT the_geom, yymmdd as date, mag FROM {{table_name}} WHERE the_geom IS NOT NULL ORDER BY date ASC", {table_name: 'earthquakes_netherlands'})
	    //   .done(function(collection) {
	    //     earthquakes = collection.features;
	    //     quake();
	    //   });

	    // var i = 0;
	    // function quake() {
	    //   var c = earthquakes[i];

	    //   svg.append("circle")
	    //       .attr("cx", xy(c.geometry.coordinates)[0])
	    //       .attr("cy", xy(c.geometry.coordinates)[1])
	    //       .attr("r", 1)
	    //       .style("fill", "red")
	    //       .style("fill-opacity", 0.5)
	    //       .style("stroke", "red")
	    //       .style("stroke-opacity", 0.5)
	    //     .transition()
	    //       .duration(2000)
	    //       .ease(Math.sqrt)
	    //       .attr("r", parseFloat(c.properties.mag.replace(",", ".")) * 20)
	    //       .style("fill-opacity", 1e-6)
	    //       .style("stroke-opacity", 1e-6)
	    //       .remove()
	    //     setTimeout(quake, 200);
	    //   i++;
	    //   if (earthquakes.length==i) i = 0;
	// }

    // must be named this way to match earthquake feed
    function earthquakes_callback(data) {

        var svg = d3.select("#earthquakes")

        // var updated = new Date(data.metadata.generated);
        // var format = d3.time.format("%I:%M:%S %p");

        // d3.select("#time").text(format(updated));

        // console.log("Currently: " + format(new Date()) + ", " +
        //     "Last Generated: " + format(updated));

        // handling updates are difficult
        // http://bost.ocks.org/mike/join/
        // http://bl.ocks.org/mbostock/3808234

        // get any existing circles
        var quakes = svg.selectAll("circle").data(data.features)

        var radius = d3.scale.pow()
            .range([2, 12])
            .domain([0, 10]);

        // add new circles for new earthquakes
        
        quakes.enter()
            .append("circle")
            .attr("cx", function(d) {
                return xy(d.geometry.coordinates)[0]
            })
            .attr("cy", function(d) {
                return xy(d.geometry.coordinates)[1]
            })
            .attr("r", function(d) {
                return 0;
            })
            .style("fill", "red")
            .style("fill-opacity", 0)
            .style("stroke", "red")
            .style("stroke-width", "0.5px")
            .style("stroke-opacity", 1)
            .transition()
            .delay(function(d, i) {
                return i / data.features.length * 1000;
            })
            .duration(1000)
            .attr("r", function(d) {
                return radius(d.properties.mag);
            })
            .style("fill-opacity", 0.25);

        // remove circles for old earthquakes no longer in data
        quakes.exit()
            .transition()
            .attr("r", 0)
            .style("fill-opacity", 0)
            .remove();
    }

    function redraw() {
      svg.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
    }

    </script>
  </body>
</html>
